[{
    "title": "À propos de",
    "date": "",
    "description": "Hugo, le framework le plus rapide au monde pour la création de sites Web",
    "body": "Écrit dans Go, Hugo est un générateur de site statique open source disponible sous la [Apache License 2.0.] (Https://github.com/gohugoio/hugo/blob/master/LICENSE) Hugo prend en charge les types de fichiers de données TOML, YAML et JSON , Markdown et fichiers de contenu HTML et utilise des shortcodes pour ajouter du contenu riche. Les autres fonctionnalités notables sont les taxonomies, le mode multilingue, le traitement d\u0026rsquo;image, les formats de sortie personnalisés, la minification HTML / CSS / JS et la prise en charge des flux de travail Sass SCSS.\nHugo utilise une variété de projets open source, notamment:\n https://github.com/yuin/goldmark https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper  Hugo est idéal pour les blogs, les sites Web d\u0026rsquo;entreprise, les portefeuilles créatifs, les magazines en ligne, les applications d\u0026rsquo;une seule page ou même un site Web avec des milliers de pages.\nHugo est destiné aux personnes qui souhaitent coder manuellement leur propre site Web sans se soucier de la mise en place d\u0026rsquo;exécutions complexes, de dépendances et de bases de données.\nLes sites Web construits avec Hugo sont extrêmement rapides, sécurisés et peuvent être déployés n\u0026rsquo;importe où, y compris AWS, GitHub Pages, Heroku, Netlify et tout autre fournisseur d\u0026rsquo;hébergement.\nEn savoir plus et contribuer sur [GitHub] (https://github.com/gohugoio).\n",
    "ref": "/about/"
  },{
    "title": "Digital Nudging",
    "date": "",
    "description": "Influencing online User decisions on Twitter through nudge units-A hackathon experience.",
    "body": "Introduction: Here\u0026rsquo;s a fun fact; An average human being (probably an adult) makes close to 30,000 conscious decisions every day. This isn\u0026rsquo;t entirely true though, in fact, I just made that number up. I could be right because if you think about it, how many decisions would you say you make on a day to day basis? Depending on who you are the above obviously varies widely and you know best. We all make n decisions every day- what to do, eat, buy or hit. The real question however is, do our daily choices solely depend on our consciousness? Are there any other factors at hand that influence our decision making process? Are all these factors, if any, always straight forward choices or do we sometimes get \u0026ldquo;nudged\u0026rdquo; into these choices we make?\nNudge theory basically states that; by understanding how people think and what drives their decisions, we can use those factors to steer them into making decisions differently, through positive reinforcement. Research has shown that, by presenting choices differently rather than in a legislative manner, people can be influenced into making specific desired choices. This theory is widely used in behavioral economics by presenting subtle nudge units intended to influence people\u0026rsquo;s thoughts about financial products. The theory was however initially more of a moral aspect meant to help people make better decisions in life and not as a tool for commercial gain. Over years of practice, different applications of the theory emerged.\nNow that we have a basic understanding of what nudge theory is about, we can explore an applicable example. This post mainly focuses on a short research project I happened to be part of, actually my first hackathon experience hosted by Safaricom PLC. Let\u0026rsquo;s dive in!\nThe Challenge This photo a team mate took at the hackathon contains a problem statement for the challenge:\n\r  Figure 1: The challenge\n  \rTools used: Our twitter data was fetched using R, I have done a post on setting up a twitter API to fetch twitter data here. R has several packages (such as \u0026ldquo;tweeteR\u0026rdquo; and \u0026ldquo;rtweet\u0026rdquo;) that one can use to stream data from twitter. Our data cleaning and pre-processing was mainly done in Python.\n Note: To keep this post concise, code for the workings has been minimized. The source code for this post can be found here, for anyone interested in trying out the same process. The code is well commented for easier understanding as well.\n 1.Fetching Data The team agreed on a few terms to query data on from twitter. For an unbiased range of topics, we settled on fetching tweets under trending topics and a few more from random words. We had tweets from or containing the following:\n #MenConference2019 “Here” #r_Stats “PWC” #Friday Feeling  # Install And Load Requried Packages\rinstall.packages(\u0026quot;twitteR\u0026quot;) #install package if not yet\rinstall.packages(\u0026quot;rtweet\u0026quot;) #install package if not yet\r#Load\rlibrary(\u0026quot;twitteR\u0026quot;)#------Extracts data from twitter\rlibrary(\u0026quot;rtweet\u0026quot;)#------Extracts data from twitter\r# create token named \u0026quot;twitter_token\u0026quot;\rtwitter_token \u0026lt;- create_token(\rapp = \u0026quot;BeyondRawData\u0026quot;, #The name of your twitter API app\rconsumer_key \u0026lt;- '4VfuSFDGSHF4566kssgmsgUUUDsff2',\rconsumer_secret \u0026lt;- 'ughjslkuynmwrtwtmwtoae',\raccess_token \u0026lt;- '6768w69w7twtw-BPHBOQT0pNdfhyFZzJ2jAsdffdRtgjgsfslZwpm',\raccess_secret \u0026lt;- '(9rHttKGJnaAVxMZHJhaxKbLt)9opodfggdgqBEHprqYnTpN5ysy')\r#Connect to twitter and fetch data\rrstats_tweets \u0026lt;- search_tweets(q = \u0026quot;#rstats\u0026quot;, n = 500)\rrstats_tweets2 \u0026lt;- search_tweets(q = \u0026quot;#rstats\u0026quot;, n = 5000) friday_Feeling \u0026lt;- search_tweets( q = \u0026quot;#FridayFeeling\u0026quot;, n = 500)\rHere_Tweet \u0026lt;- search_tweets( q = \u0026quot;here\u0026quot;, n = 500)\rPWc_Tweet \u0026lt;- search_tweets( q = \u0026quot;PWC\u0026quot;, n = 500)\r#Bind tweets to one data frame\rbind_Data\u0026lt;- rbind(rstats_tweets,rstats_tweets2,friday_Feeling,Here_Tweet,PWc_Tweet)\rbind_Data\u0026lt;- as.data.frame(bind_Data)\rA total of 7000 tweets were captured. The data frame had a total of 88 columns which we treated as variables for the research. However, not all variables were used in the research we therefore had to do some data cleaning. Here is a preview of the variables in our raw data.\n\u0026gt; bind_Data\u0026lt;- as.data.frame(bind_Data)\r\u0026gt; names(bind_Data)\r[1] \u0026quot;user_id\u0026quot; \u0026quot;status_id\u0026quot; \u0026quot;created_at\u0026quot; [4] \u0026quot;screen_name\u0026quot; \u0026quot;text\u0026quot; \u0026quot;source\u0026quot; [7] \u0026quot;display_text_width\u0026quot; \u0026quot;reply_to_status_id\u0026quot; \u0026quot;reply_to_user_id\u0026quot; [10] \u0026quot;reply_to_screen_name\u0026quot; \u0026quot;is_quote\u0026quot; \u0026quot;is_retweet\u0026quot; [13] \u0026quot;favorite_count\u0026quot; \u0026quot;retweet_count\u0026quot; \u0026quot;hashtags\u0026quot; [16] \u0026quot;symbols\u0026quot; \u0026quot;urls_url\u0026quot; \u0026quot;urls_t.co\u0026quot; [19] \u0026quot;urls_expanded_url\u0026quot; \u0026quot;media_url\u0026quot; \u0026quot;media_t.co\u0026quot; [22] \u0026quot;media_expanded_url\u0026quot; \u0026quot;media_type\u0026quot; \u0026quot;ext_media_url\u0026quot; [25] \u0026quot;ext_media_t.co\u0026quot; \u0026quot;ext_media_expanded_url\u0026quot; \u0026quot;ext_media_type\u0026quot; [28] \u0026quot;mentions_user_id\u0026quot; \u0026quot;mentions_screen_name\u0026quot; \u0026quot;lang\u0026quot; [31] \u0026quot;quoted_status_id\u0026quot; \u0026quot;quoted_text\u0026quot; \u0026quot;quoted_created_at\u0026quot; [34] \u0026quot;quoted_source\u0026quot; \u0026quot;quoted_favorite_count\u0026quot; \u0026quot;quoted_retweet_count\u0026quot; [37] \u0026quot;quoted_user_id\u0026quot; \u0026quot;quoted_screen_name\u0026quot; \u0026quot;quoted_name\u0026quot; [40] \u0026quot;quoted_followers_count\u0026quot; \u0026quot;quoted_friends_count\u0026quot; \u0026quot;quoted_statuses_count\u0026quot; [43] \u0026quot;quoted_location\u0026quot; \u0026quot;quoted_description\u0026quot; \u0026quot;quoted_verified\u0026quot; [46] \u0026quot;retweet_status_id\u0026quot; \u0026quot;retweet_text\u0026quot; \u0026quot;retweet_created_at\u0026quot; [49] \u0026quot;retweet_source\u0026quot; \u0026quot;retweet_favorite_count\u0026quot; \u0026quot;retweet_retweet_count\u0026quot; [52] \u0026quot;retweet_user_id\u0026quot; \u0026quot;retweet_screen_name\u0026quot; \u0026quot;retweet_name\u0026quot; [55] \u0026quot;retweet_followers_count\u0026quot; \u0026quot;retweet_friends_count\u0026quot; \u0026quot;retweet_statuses_count\u0026quot; [58] \u0026quot;retweet_location\u0026quot; \u0026quot;retweet_description\u0026quot; \u0026quot;retweet_verified\u0026quot; [61] \u0026quot;place_url\u0026quot; \u0026quot;place_name\u0026quot; \u0026quot;place_full_name\u0026quot; [64] \u0026quot;place_type\u0026quot; \u0026quot;country\u0026quot; \u0026quot;country_code\u0026quot; [67] \u0026quot;geo_coords\u0026quot; \u0026quot;coords_coords\u0026quot; \u0026quot;bbox_coords\u0026quot; [70] \u0026quot;status_url\u0026quot; \u0026quot;name\u0026quot; \u0026quot;location\u0026quot; [73] \u0026quot;description\u0026quot; \u0026quot;url\u0026quot; \u0026quot;protected\u0026quot; [76] \u0026quot;followers_count\u0026quot; \u0026quot;friends_count\u0026quot; \u0026quot;listed_count\u0026quot; [79] \u0026quot;statuses_count\u0026quot; \u0026quot;favourites_count\u0026quot; \u0026quot;account_created_at\u0026quot; [82] \u0026quot;verified\u0026quot; \u0026quot;profile_url\u0026quot; \u0026quot;profile_expanded_url\u0026quot; [85] \u0026quot;account_lang\u0026quot; \u0026quot;profile_banner_url\u0026quot; \u0026quot;profile_background_url\u0026quot; [88] \u0026quot;profile_image_url\u0026quot; [1] \u0026quot;user_id\u0026quot; \u0026quot;status_id\u0026quot; \u0026quot;created_at\u0026quot; [4] \u0026quot;screen_name\u0026quot; \u0026quot;text\u0026quot; \u0026quot;source\u0026quot; [7] \u0026quot;display_text_width\u0026quot; \u0026quot;reply_to_status_id\u0026quot; \u0026quot;reply_to_user_id\u0026quot; [10] \u0026quot;reply_to_screen_name\u0026quot; \u0026quot;is_quote\u0026quot; \u0026quot;is_retweet\u0026quot; [13] \u0026quot;favorite_count\u0026quot; \u0026quot;retweet_count\u0026quot; \u0026quot;hashtags\u0026quot; [16] \u0026quot;symbols\u0026quot; \u0026quot;urls_url\u0026quot; \u0026quot;urls_t.co\u0026quot; [19] \u0026quot;urls_expanded_url\u0026quot; \u0026quot;media_url\u0026quot; \u0026quot;media_t.co\u0026quot; [22] \u0026quot;media_expanded_url\u0026quot; \u0026quot;media_type\u0026quot; \u0026quot;ext_media_url\u0026quot; [25] \u0026quot;ext_media_t.co\u0026quot; \u0026quot;ext_media_expanded_url\u0026quot; \u0026quot;ext_media_type\u0026quot; [28] \u0026quot;mentions_user_id\u0026quot; \u0026quot;mentions_screen_name\u0026quot; \u0026quot;lang\u0026quot; [31] \u0026quot;quoted_status_id\u0026quot; \u0026quot;quoted_text\u0026quot; \u0026quot;quoted_created_at\u0026quot; [34] \u0026quot;quoted_source\u0026quot; \u0026quot;quoted_favorite_count\u0026quot; \u0026quot;quoted_retweet_count\u0026quot; [37] \u0026quot;quoted_user_id\u0026quot; \u0026quot;quoted_screen_name\u0026quot; \u0026quot;quoted_name\u0026quot; [40] \u0026quot;quoted_followers_count\u0026quot; \u0026quot;quoted_friends_count\u0026quot; \u0026quot;quoted_statuses_count\u0026quot; [43] \u0026quot;quoted_location\u0026quot; \u0026quot;quoted_description\u0026quot; \u0026quot;quoted_verified\u0026quot; [46] \u0026quot;retweet_status_id\u0026quot; \u0026quot;retweet_text\u0026quot; \u0026quot;retweet_created_at\u0026quot; [49] \u0026quot;retweet_source\u0026quot; \u0026quot;retweet_favorite_count\u0026quot; \u0026quot;retweet_retweet_count\u0026quot; [52] \u0026quot;retweet_user_id\u0026quot; \u0026quot;retweet_screen_name\u0026quot; \u0026quot;retweet_name\u0026quot; [55] \u0026quot;retweet_followers_count\u0026quot; \u0026quot;retweet_friends_count\u0026quot; \u0026quot;retweet_statuses_count\u0026quot; [58] \u0026quot;retweet_location\u0026quot; \u0026quot;retweet_description\u0026quot; \u0026quot;retweet_verified\u0026quot; [61] \u0026quot;place_url\u0026quot; \u0026quot;place_name\u0026quot; \u0026quot;place_full_name\u0026quot; [64] \u0026quot;place_type\u0026quot; \u0026quot;country\u0026quot; \u0026quot;country_code\u0026quot; [67] \u0026quot;geo_coords\u0026quot; \u0026quot;coords_coords\u0026quot; \u0026quot;bbox_coords\u0026quot; [70] \u0026quot;status_url\u0026quot; \u0026quot;name\u0026quot; \u0026quot;location\u0026quot; [73] \u0026quot;description\u0026quot; \u0026quot;url\u0026quot; \u0026quot;protected\u0026quot; [76] \u0026quot;followers_count\u0026quot; \u0026quot;friends_count\u0026quot; \u0026quot;listed_count\u0026quot; [79] \u0026quot;statuses_count\u0026quot; \u0026quot;favourites_count\u0026quot; \u0026quot;account_created_at\u0026quot; [82] \u0026quot;verified\u0026quot; \u0026quot;profile_url\u0026quot; \u0026quot;profile_expanded_url\u0026quot; [85] \u0026quot;account_lang\u0026quot; \u0026quot;profile_banner_url\u0026quot; \u0026quot;profile_background_url\u0026quot; [88] \u0026quot;profile_image_url\u0026quot;  2.Data pre-processing. This stage involved cleaning up our data by removing the unwanted columns/variables. We decided to do with a select few variables we thought would be most appropriate for our case study. We chose the following seven variables:\n Text - This column contained the actual tweets text. Verified - whether or not the user is verified on twitter. Protected - Whether a user is or isn\u0026rsquo;t protected (Locked accounts). Location - Based on our challenge stated in the figure above, this variable was our most important variable. Rows with NULL values for location simply meant that the specific user DID NOT GEOTAG their tweet. Followers Count - Number of followers the user had. Retweet Verifie - Whether the tweet had been retweeted by a verified user or not. Source - Source of the tweet i.e \u0026ldquo;Android\u0026rdquo;, \u0026ldquo;web client\u0026rdquo; e.t.c  #Removing unusable variables--They apear as lists in the data\rbind_Data\u0026lt;-subset(bind_Data, select = -c(hashtags,symbols,\rurls_url,urls_t.co,\rurls_expanded_url,media_url,\rmedia_t.co,media_expanded_url,media_type,ext_media_url,\rext_media_t.co,ext_media_expanded_url,mentions_user_id,\rmentions_screen_name,geo_coords,coords_coords,bbox_coords))\r#selecting variables to use in analysis.\rselected_Variables\u0026lt;- subset(bind_Data, select = c(text, verified, protected, location, followers_count, retweet_verified, source))\rnames(selected_Variables)\r##Output \u0026gt; names(selected_Variables)\r[1] \u0026quot;text\u0026quot; \u0026quot;verified\u0026quot; \u0026quot;protected\u0026quot; \u0026quot;location\u0026quot; [5] \u0026quot;followers_count\u0026quot; \u0026quot;retweet_verified\u0026quot; \u0026quot;source\u0026quot; #write the data into a CSV file and load intopython for cleanup\rwrite.csv(selected_Variables,\u0026quot;Myvariables.csv\u0026quot;)#Write CSV to a working directory then clean up using python #To check your working directory, do:\rgetwd() #--For example, mine is [1] \u0026quot;J:/Personalprojects/SafComHackathon/Tweeter\u0026quot;\rCode for the data cleanup and variables setting that was done in Python can be found here.\n2.1 Re-importing Data in R and setting up for the Models After cleaning up the data, we imported it into R, the code chunk shows a preview of the top 4 rows of the input data.\n\u0026gt; #Data Prep\r\u0026gt; #Shuffle data\r\u0026gt; index.shuffle \u0026lt;- sample(1:nrow(data)) #Shuffle data index to randomize contents and remove bias\r\u0026gt; #Data\r\u0026gt; data\u0026lt;-read.csv(\u0026quot;Variables3.csv\u0026quot;, stringsAsFactors = TRUE) #read CSV data that had been cleade up in Python\r\u0026gt; data \u0026lt;- data[index.shuffle, ]\r\u0026gt; head(data, 4)\rX\r1074 1074\r1316 1316\r2636 2636\r2939 2939\rText\r1074 Want to know how to optimize hyper-parameters in Caret with cost-specific functions? #rstats #datascience https://t.co/cupvirSXU9\r1316 via @RichardEudes - Quick Guide to R and Statistical Programming https://t.co/GfyhLMgiuB #analytics, #datascience, #rstats, #statistics https://t.co/Cx3TGJTOoI\r2636 small #rstats trick: if you need to know if a *sorted* variable is equally spaced (e.g., if it's a contiguous sequence of ints, which was my use case) you can look at the characteristics of diff(x), e.g.\\n\\nsummary(diff(x))\\ntable(diff(x))\r2939 my #ggplot2 flipbook project is online! \u0026lt;U+0001F60E\u0026gt;\u0026lt;U+0001F913\u0026gt;\u0026lt;U+0001F913\u0026gt; Incrementally walks through plotting code (#MakeoverMonday, soon #TidyTuesday plots). Using #xaringan with reveal function; thanks, @statsgen @grrrck. #rstats. https://t.co/bBBzv0iZLw https://t.co/tFtD78IOHZ\rVerified Protected Location Followers VerifiedRetweet\r1074 FALSE FALSE Singapore 1570 FALSE\r1316 FALSE FALSE Paris, France 2151 NA\r2636 FALSE FALSE Pleasant Hill, CA 1207 NA\r2939 FALSE FALSE Sri Lanka 2623 FALSE\rCharacters\r1074 DS-retweet\r1316 IFTTT\r2636 Twitter Web Client\r2939 Twitter for Android\rText\r1074 Want to know how to optimize hyper-parameters in Caret with cost-specific functions? #rstats #datascience https://t.co/cupvirSXU9\r1316 via @RichardEudes - Quick Guide to R and Statistical Programming https://t.co/GfyhLMgiuB #analytics, #datascience, #rstats, #statistics https://t.co/Cx3TGJTOoI\r2636 small #rstats trick: if you need to know if a *sorted* variable is equally spaced (e.g., if it's a contiguous sequence of ints, which was my use case) you can look at the characteristics of diff(x), e.g.\\n\\nsummary(diff(x))\\ntable(diff(x))\r2939 my #ggplot2 flipbook project is online! \u0026lt;U+0001F60E\u0026gt;\u0026lt;U+0001F913\u0026gt;\u0026lt;U+0001F913\u0026gt; Incrementally walks through plotting code (#MakeoverMonday, soon #TidyTuesday plots). Using #xaringan with reveal function; thanks, @statsgen @grrrck. #rstats. https://t.co/bBBzv0iZLw https://t.co/tFtD78IOHZ\rVerified Protected Location Followers VerifiedRetweet\r1074 FALSE FALSE Singapore 1570 FALSE\r1316 FALSE FALSE Paris, France 2151 NA\r2636 FALSE FALSE Pleasant Hill, CA 1207 NA\r2939 FALSE FALSE Sri Lanka 2623 FALSE\rCharacters\r1074 DS-retweet\r1316 IFTTT\r2636 Twitter Web Client\r2939 Twitter for Android\rWe still had to do some data pre-processing for the models which includes checking for and removing NULL values if present. Below is a sample table of the final data set used in the analysis.\n#Clean Data\rlibrary(dplyr)\r# Drop variables\rclean_data\u0026lt;- data %\u0026gt;%\rmutate( Text= as.numeric(Text),VerifiedRetweet = as.numeric(VerifiedRetweet), Characters= as.numeric(Characters),\rVerified = as.numeric(Verified), Protected = as.numeric(Protected),Location = as.numeric(Location))%\u0026gt;% data.frame()\rclean_data$Location = ifelse(clean_data$Location \u0026lt; 2, \u0026quot;NON-TAGGED\u0026quot;, \u0026quot;TAGGED\u0026quot;) #set geotags to true or false clean_data$Followers = ifelse(clean_data$Followers \u0026lt; 500, 0, 1) # if number of followers is greater than 500 then TRUE\ris.na(clean_data$VerifiedRetweet) \u0026lt;- 1 #Remove NA values\rclean_data[is.na(clean_data[-1,])] = 1 #Convert NA values to 1\r#View(clean_data)\rhead(clean_data)\r#Output\r\u0026gt; head(clean_data)\rVerified Protected Location Followers VerifiedRetweet Characters\r1 0 0 TAGGED 1 1 55\r2 1 1 NON-TAGGED 1 1 80\r3 0 0 TAGGED 1 1 193\r4 0 0 TAGGED 1 0 188\r5 1 0 TAGGED 0 1 188\r6 0 0 NON-TAGGED 0 0 190\r\u0026gt;    Verified Protected Location Followers VerifiedRetweet Characters     NO NO TAGGED \u0026gt;500 YES 55   YES YES NON-TAGGED \u0026gt;500 YES 80   NO NO TAGGED \u0026gt;500 YES 193   NO NO TAGGED \u0026gt;500 NO 188   YES NO TAGGED 500\u0026lt; YES 188   NO NO NON-TAGGED 500\u0026lt; NO 190    From the table above, we can observe a new column \u0026ldquo;Characters\u0026rdquo;. This was an additional variable derived by counting the number of characters in the tweet text.\n3.Model Specifications Due to the nature of our problem,(we had several uncorrelated variables) we decided to do a classification analysis. This means we had to come up with a classifier model to regress n variables based on our dependent variable, the Location variable. The main challenge of classifier models is knowing what really goes on inside the models that leads to the final output. Even with higher levels of accuracy in some models, it is quite difficult o understand the paths of a given model. However, using Random forests and Decision Tree classifiers can give us a graphical representation of the criteria followed by the models to arrive at a given output. Another upper hand of decision tree models is that they require minimal data cleaning, less time consuming. Here is a detailed read on how decision trees work.\nCreating Train \u0026amp; Test Sets. For the training and test data sets, we randomly split our data set into two sates. Usually, the best practice is to train the model with with a larger proportion of the data set. We therefore took 80% for training and 20% for test purposes.\n#Train \u0026amp; Test sets\rcreate_train_test\u0026lt;- function(data, size = 0.8, train = TRUE) {\rn_row = nrow(data)\rtotal_row = size * n_row\rtrain_sample\u0026lt;- 1: total_row\rif (train == TRUE) {\rreturn (data[train_sample, ])\r} else {\rreturn (data[-train_sample, ])\r}\r}\rclean_data1 = subset(clean_data, select = -c(X,Protected) ) #remove unwanted variables\rdata_train \u0026lt;- create_train_test(clean_data1, 0.8, train = TRUE)\rdata_test \u0026lt;- create_train_test(clean_data1, 0.8, train = FALSE)\rdim(data_train) #Checkdimensions for train data\rdim(data_test) #Checkdimensions for test data\r\nModel Training. We trained our decision tree model to predict a class \u0026ldquo;location\u0026rdquo;. Whether a location is geotagged or not geotagged based on whether the user is verified, protected, has over 500 followers, is retweeted by another verified user and the number of characters in their tweet. Bellow is the visual output of the trained model.\n#install.packages(\u0026quot;rpart.plot\u0026quot;)\t-This is for decision trees.\r#Create and fit model\rlibrary(rpart)#load package\rlibrary(rpart.plot)#load package\rfit \u0026lt;- rpart(Location ~ ., data = data_train, method = 'class')\r# set.seed(27)\r# fit \u0026lt;- rpart(Location ~ .,\r# data = data_train,\r# method = \u0026quot;class\u0026quot;,\r# control = rpart.control(xval = 10, minbucket = 2, cp = 0), parms = list(split = \u0026quot;information\u0026quot;))\rrpart.plot(fit)\r\r  Figure 2: The Tree\n  \rWhen interpreting decision trees, you start at the root node. The root node is the one on top of the decision tree. Since what we want is those nodes with geotagged locations, it is safe to ignore the non-tagged nodes. Note that our highest entropy level was observed on one variable only, the number of characters in the tweet text. This might not always be the case with decision trees though, it is possible to have more than one factor. In such situations, it is best to run several decision trees to build a random forest and make a decision based on the most prevalent variables.\nFor our case, we only focus on what we found:\n  At the top node, we can see the overall probability of a user geotagging their tweets. 75 percent of the users in the training set geotagged their tweets. not\n  Our second node asks whether the number of characters are more than 134 and goes to depth 2 where we can observe the highest number of users tweeted more than 134 characters at 80 percent with an 80 percent probability of geotagging their tweets.\n  Node 3 checks if the number of characters in a tweet is less than 134. If yes, head to depth 3, where we can see that 20 percent of users had less than 134 characters with a 50 percent probability of geotagging their tweets.\n  Finally, looking at depth 4 which originates from the node that checks is number of characters is equal to or more than 122, we can see that 12 percent of users had tweets with character equal to or more than 124, with 88 percent probability of geotagging their tweets.\n  3.1 Model Testing and performance accuracy. With our model trained and outputs observed, we were able to run a test with our test subset. Here is our confusion matrix.\n#Predicting\rpredict_geotags \u0026lt;-predict(fit, data_test, type = 'class')\rtable_mat \u0026lt;- table(data_test$Location, predict_geotags)\r\u0026gt; table_mat\rpredict_geotags\rNON-TAGGED TAGGED\rNON-TAGGED 90 248\rTAGGED 2 1043\r#performance\raccuracy_Test \u0026lt;- sum(diag(table_mat)) / sum(table_mat)\rprint(paste('Accuracy for test is', accuracy_Test))\r[1] \u0026quot;Accuracy for test is 0.819233550253073\u0026quot;\rConfusion matrix predict_geotags\rNON-TAGGED TAGGED\rNON-TAGGED 90 248\rTAGGED 2 1043\r\nModel Accuracy \u0026gt; #performance\r\u0026gt; accuracy_Test \u0026lt;- sum(diag(table_mat)) / sum(table_mat)\r\u0026gt; print(paste('Accuracy for test is', accuracy_Test))\r[1] \u0026quot;Accuracy for test is 0.819233550253073\u0026quot;\rFrom the confusion matrix above, we can observe that the model had a true negative of 90 predictions. That is, 90 predictions were correctly predicted as not geotagged. A false positive of 248 predictions was observed where the model wrongly predicted 248 tweets were geotagged whereas in real sense they were not.\nFor the tagged tweets, we had a false negative of 2 predictions against a true positive of 1043 predictions. This means that our model was able to correctly predict 1043 geotagged tweets from the test data. The accuracy of the model turned out pretty good, at an 82 percent accuracy level. The theoretical formula for the accuracy is the proportion of true positives and the true negatives divided by the sum of the confusion matrix.\n\r$$Accuracy = \\frac{TP + TN}{TP + TN + FP + FN}$$\n\rFor a better accuracy level, the model\u0026rsquo;s hyper-parameters can be tweaked to improve performance. Another option is implementing a random forest test.\n4. Conclusion and Recommendation With our decision tree model, we were able to attain a high level of accuracy for a model that test whether users with tweets containing characters equal to or above 122 are likely to geotag their tweets. Our nudge in this case is the number of characters in a tweet and precisely, 124 or more. Our recommendation therefore would be to encourage users to tweet longer or engage them in trending topics that require one to write more, for example a TT like # MyLifeHistoryInANutshell\u0026hellip;-in the hope that a user will eventually geotag their tweet.\n Come to think of it, did twitter really increase the number of characters just for tweeps to tweet more and as they said, to get more people to join twitter? I can be a good conspiracy theorist\u0026hellip;\n References   Business balls official website\n  Thaler, R.H., Sunstein, C.R., and Balz, J.P. Choice Architecture. SSRN Electronic Journal (2010), 1–18; https://ssrn.com/abstract=1583509\n  Thaler, R.H. and Sunstein, C.R. Nudge: Improving Decisions About Health, Wealth, and Happiness. Yale University Press, New Haven, CT, and London, U.K., 2008.\n  \r\r",
    "ref": "/blog/digital-nudging/digital-nudging/"
  },{
    "title": "Twitter Data Mining In R",
    "date": "",
    "description": "Getting started with Text mining using Twitter and R.",
    "body": "knitr::opts_chunk$set(collapse = TRUE) Part I  This first section assumes you have no knowledge in building a twitter app to be used for fetching data. You can skip directly to the second section here if you are able to build your own twitter app and get the required authentication keys.\n Introduction: Social media usage has grown rapidly over the past few decades. Most social networks we can think of now are so well established, making them a platform where people can not only interact but also a haven for anyone in need of \u0026ldquo;unstructured\u0026rdquo; data. With an almost constant rate of increasing users each day, social networks such as Facebook and Twitter have become great sources of data which can be used in the broad field of Data Science:Talk of (those pretty annoying) targeted ads for example\u0026hellip;\n    With the help of APIs, we are easily able to get data from such platforms to be used for further analysis. In this article we will go through the preliminaries of text mining in R using Twitter data. The main advantage of these APIs is that the data we will fetch comes in a well-structured format which makes our work easier when crunching. In this case we will use the readily available Twitter API and create our own Twitter app that will then help in fetching the data.\nCreating a Twitter app To create a twitter app we can use for fetching metadata, we first need to have a Twitter account. We then need to go to the twitter dev site and log in with our user account. On the top right corner should be a drop down menu next to your username, go to APPS. At this point if you are doing this for the first time your Apps section should be blank. Click on \u0026ldquo;Create an app\u0026rdquo; to\u0026hellip; create an app.\n  We then have to fill in the form below appropriately. Here is a breakdown of what\u0026rsquo;s required:\n Name: Give your app a unique name of your choice, e.g UniqueName Description: This can always be changed later, use this to provide a brief note on what your app is all about to be able to distinguish it from other apps you might create in future. Website: This should be your application\u0026rsquo;s home page web site. It is however not applicable for most personal apps. Anything goes here e.g https://carlvinjerry.github.io Callback URL: I would ignore the Callback URL field. If you are allowing users to log into your app to authenticate themselves, you\u0026rsquo;d enter the URL where they would be returned after they\u0026rsquo;ve given permission to Twitter to use your app.    The remaining fields should be quite straight forward but must be filled. Click \u0026ldquo;Create\u0026rdquo; once done and there you have your first twitter app. On your app is a menu with Keys and tokens. These are the most important components since we will need them to access data from the API.Generate both consumer and access tokens (if not readily available) and take note of them. NB: Keys are private property\u0026hellip;most of the times\n   Figure:Keys\n   The final bit of setting up our twitter app is granting access permissions. We will mostly do fine with read-only if all we need is to fetch data but it can always be changed later.\n   Figure:Permisions\n   \nNow we can move on to the next step where we set up R to query data from Twitter.\n  Part II Setting up R to fetch twitter data With our twitter app set up in part I above and we are able to get the authentication keys for the API, we can now easily fetch data from twitter in R. The following steps will help us do this:\n div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;}  Prerequisites:  Twitter API Keys: At this point we already have our twitter app with the required API keys. R and an IDE of choice: We also need to have R installed, advisably the latest version. Microsoft\u0026rsquo;s enhanced R distribution is recommended over the base R but for this specific task either can do just fine. I would recommend R STUDIO for an IDE. One obvious advantage of all these is that they\u0026rsquo;re open-source tools.   1.Install and Load the required packages in R R has a standard set of packages, each with different tasks. You can find some packages for download\nhere. The code chunk below installs and loads the specific packages we need for this task. Take note of comments at each line of code, initiated by an octothorp.\n# Install packages install.packages(\u0026quot;twitteR\u0026quot;) #------Extracts data from twitter install.packages(\u0026quot;httr\u0026quot;) #--------Tools for Working with URLs and HTTP # We can now load the two packages library(\u0026quot;twitteR\u0026quot;) require(\u0026quot;httr\u0026quot;) #-------------Both require() and library() can be used to call an installed package \nNB: Windows users might need to download a certification file and store it in the working directory. This certificate file initiates a handshake between R and the Twitter API.\n# Download \u0026quot;cacert.pem\u0026quot; file download.file(url = \u0026quot;https://curl.haxx.se/ca/cacert.pem\u0026quot;, destfile = \u0026quot;cacert.pem\u0026quot;) \n2.Create and store objects containing the twitter authenticated credentials This is where we invoke the twitter API using the credentials from our app and query the data we need.\n# Authentication keys consumer_key \u0026lt;- \u0026quot;hjksdha08097afnjhaa90uaf\u0026quot; consumer_secret \u0026lt;- \u0026quot;hjksdha08097afnjhaa90uaf\u0026quot; access_token \u0026lt;- \u0026quot;hjksdha08097afnjhaa90uaf\u0026quot; access_secret \u0026lt;- \u0026quot;hjksdha08097afnjhaa90uaf\u0026quot; # The above tokens are what we made the twitter app for. \n3.Query data from twitter We can now go ahead and fetch our data. Due to limitations on the twitter standard apps, it is advisable to store your data in R locally. This will reduce the number of times you have to make requests to fetch data. You will therefore do much more with your app that way regardless of the limitations- Or you can as well buy the premium rights. In my example below, I am fetching data for a user on twitter called @UKenyatta.\n# Connect to Twitter setup_twitter_oauth(consumer_key, consumer_secret, access_token, access_secret) tweets \u0026lt;- userTimeline(\u0026quot;UKenyatta\u0026quot;, n = 3200) # Standard twitter apps are limited to 3200 tweets per #download session. This could come out less depending on # the app # create a data frame of the tweets UKenyatta_Tweets \u0026lt;- tbl_df(map_df(tweets, as.data.frame)) # Save tweets for later (and note when saved): save(UKenyatta_Tweets, file = \u0026quot;UKenyatta_Tweets.RData\u0026quot;) # You can then access them later at will... # load(\u0026quot;UKenyatta_Tweets.RData\u0026quot;) You can now manipulate your data and see what you find out\u0026hellip;\n  ",
    "ref": "/blog/twitter-data-mining/twitter-data-mining/"
  },{
    "title": "Kontakt",
    "date": "",
    "description": "",
    "body": "",
    "ref": "/contact/"
  }]
